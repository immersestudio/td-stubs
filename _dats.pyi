import typing as _T

if False:
	from td import *

_NameOrIndex = _T.Union[str, int, 'Cell', 'Channel']
_NamesOrIndices = _T.Iterable[_NameOrIndex]

# noinspection PyAbstractClass
class Cell(_T.SupportsInt, _T.SupportsAbs, _T.SupportsFloat, _T.SupportsBytes):
	val: str
	row: int
	col: int

	def offset(self, r: int, c: int) -> _T.Optional['Cell']: ...

class DAT(OP):
	def row(self, *nameorindex: _NameOrIndex, caseSensitive=True) -> _T.List[Cell]: ...
	def col(self, *nameorindex: _NameOrIndex, caseSensitive=True) -> _T.List[Cell]: ...
	def rows(self, *nameorindex: _NameOrIndex, caseSensitive=True) -> _T.List[_T.List[Cell]]: ...
	def cols(self, *nameorindex: _NameOrIndex, caseSensitive=True) -> _T.List[_T.List[Cell]]: ...
	def clear(self, keepSize=False, keepFirstRow=False, keepFirstCol=False): ...

	# noinspection PyMethodOverriding
	def copy(self, dat: 'DAT'): ...

	def appendRow(self, cells: _T.List[_T.Any], nameOrIndex: _NameOrIndex = None, sort: _NameOrIndex = None): ...
	def appendCol(self, cells: _T.List[_T.Any], nameOrIndex: _NameOrIndex = None, sort: _NameOrIndex = None): ...
	def appendRows(self, cells: _T.List[_T.List[_T.Any]], nameOrIndex: _NameOrIndex = None, sort: _NameOrIndex = None): ...
	def appendCols(self, cells: _T.List[_T.List[_T.Any]], nameOrIndex: _NameOrIndex = None, sort: _NameOrIndex = None): ...
	def insertRow(self, vals: _T.List[_T.Any], nameOrIndex: _NameOrIndex, sort=None) -> int: ...
	def insertCol(self, vals: _T.List[_T.Any], nameOrIndex: _NameOrIndex, sort=None) -> int: ...
	def replaceRow(self, nameOrIndex: _NameOrIndex, vals: _T.List[_T.Any], entireRow=True) -> int: ...
	def replaceCol(self, nameOrIndex: _NameOrIndex, vals: _T.List[_T.Any], entireCol=True) -> int: ...
	def deleteRow(self, nameOrIndex: _NameOrIndex): ...
	def deleteCol(self, nameOrIndex: _NameOrIndex): ...
	def deleteRows(self, vals: _NamesOrIndices): ...
	def deleteCols(self, vals: _NamesOrIndices): ...
	def setSize(self, numrows: int, numcols: int): ...
	def __getitem__(self, rowcol: _T.Tuple[_NameOrIndex, _NameOrIndex]) -> Cell: ...
	def __setitem__(self, rowcol: _T.Tuple[_NameOrIndex, _NameOrIndex], value): ...
	def cell(self, rowNameOrIndex: _NameOrIndex, colNameOrIndex: _NameOrIndex, caseSensitive=True) -> _T.Optional[Cell]:
		...
	def cells(self, rowNameOrIndex: _NameOrIndex, colNameOrIndex: _NameOrIndex, caseSensitive=True) -> _T.List[Cell]: ...
	def findCell(
			self,
			pattern: str,
			rows: _T.Optional[_NamesOrIndices] = None,
			cols: _T.Optional[_NamesOrIndices] = None,
			valuePattern=True, rowPattern=True, colPattern=True, caseSensitive=False) -> _T.Optional[Cell]: ...
	def findCells(
			self,
			pattern: str,
			rows: _T.Optional[_NamesOrIndices] = None,
			cols: _T.Optional[_NamesOrIndices] = None,
			valuePattern=True, rowPattern=True, colPattern=True, caseSensitive=False) -> _T.List[Cell]: ...
	def write(self, *args, **kwargs) -> str: ...
	def run(
			self, *args, endFrame=False, fromOP: 'OP' = None, asParameter=False, group=None, delayFrames=0,
			delayMilliSeconds=0, delayRef: 'OP' = None) -> Run: ...
	def save(self, filepath: str = None, append=False, createFolders=False) -> str: ...
	module: 'MOD'
	numRows: int
	numCols: int
	text: str
	isTable: bool
	isText: bool
	locals: _T.Dict[str, _T.Any]

class scriptDAT(DAT):
	def destroyCustomPars(self): ...
	def sortCustomPages(self, *pages): ...
	def appendCustomPage(self, name: str) -> 'Page': ...

class evaluateDAT(DAT):
	exprCell: 'Cell'
	exprCol: int
	exprRow: int
	exprTable: 'DAT'
	inputCell: 'Cell'
	inputCol: int
	inputRow: int
	inputTable: 'DAT'

class oscoutDAT(DAT):
	def sendBytes(self, *messages) -> int: ...

	def sendOSC(
			self, *addressesFollowedByValueLists: _T.Union[str, _T.List[_T.Any]],
			asBundle=True, useNonStandardTypes=True, use64BitPrecision=False) -> int: ...

	def send(self, *messages: str, terminator='') -> int: ...

oscinDAT = oscoutDAT

class webclientDAT(DAT):
	def request(
			self,
			url: str,
			method: str,
			header: dict = None,
			data=None,
			pars: dict = None,
			authType: str = None,
			username: str = None,
			password: str = None,
			appKey: str = None,
			appSecret: str = None,
			oauth1Token: str = None,
			oauth1Secret: str = None,
			oauth2Token: str = None,
			uploadFile: str = None,
	) -> None: ...

	def closeConnection(self, id: int): ...

class udpinDAT(DAT):
	def sendBytes(self, *messages) -> int: ...
	def sendOSC(
			self, address: str, *values, asBundle=False, useNonStandardTypes=True, use64BitPrecision=False) -> int: ...
	def send(self, *messages: str, terminator='') -> int: ...

class udtinDAT(udpinDAT):
	pass

class tcpipDAT(DAT):
	def sendBytes(self, *messages) -> int: ...
	def send(self, *messages: str, terminator='') -> int: ...

AnyDatT = _T.Union[DAT, scriptDAT, evaluateDAT, oscoutDAT, oscinDAT, webclientDAT, tcpipDAT, udpinDAT]
